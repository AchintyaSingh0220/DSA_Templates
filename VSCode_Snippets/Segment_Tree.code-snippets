{
	"Template for Segment Tree": {
		"prefix": "Segment_Tree",
		"body": [
		  "template <typename T> class SegTree",
		  "{",
		  "    public:",
		  "    vector<T> tree;",
		  "    T merge(T &a, T &b)",
		  "    {",
		  "        return a + b;",
		  "    }",
		  "    void build(vector<T> &arr, long long &n)",
		  "    {",
		  "        while(__builtin_popcount(n) != 1) n++;",
		  "        tree.resize(2 * n);",
		  "        for(int i = 0; i<arr.size(); i++){",
		  "            tree[n + i] = arr[i];",
		  "        }",
		  "        for(int i = n-1; i>=1; i--){",
		  "            tree[i] = merge(tree[2 * i], tree[2 * i + 1]);",
		  "        }",
		  "    }",
		  "    void update(int n, int idx, T val)",
		  "    {",
		  "        tree[n + idx] = val;",
		  "        for(int i = (n + idx)/2; i>=1; i /= 2) {",
		  "            tree[i] = merge(tree[2*i], tree[2*i+1]);",
		  "        }",
		  "    }",
		  "    void update(int node, int tl, int tr, int l, int r, T v)",
		  "    {",
		  "        if(tr < l || r < tl) return;",
		  "        if(l <= tl && tr <= r) {",
		  "            tree[node] = v;",
		  "            return;",
		  "        }",
		  "",
		  "        int mid = (tl + tr) / 2;",
		  "        update(2 * node, tl, mid, l, r, v);",
		  "        update(2 * node + 1, mid + 1, tr, l, r, v);",
		  "        tree[node] = merge(tree[2*node], tree[2*node+1]);",
		  "    }",
		  "    T qry(int node, int tl, int tr, int l, int r)",
		  "    {",
		  "        if(tr < l || r < tl) return 0; //here 0 is identity element",
		  "        if(l <= tl && tr <= r) return tree[node];",
		  "",
		  "        int mid = (tl + tr) / 2;",
		  "        T left = qry(2 * node, tl, mid, l, r);",
		  "        T right = qry(2 * node + 1, mid + 1, tr, l, r);",
		  "        return merge(left, right);",
		  "    }",
		  "};"
		],
		"description": "Template for Segment Tree"
	}
}